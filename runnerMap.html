<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <script src="https://atlas.microsoft.com/sdk/javascript/mapcontrol/3/atlas.min.js"></script>
    <link rel="stylesheet" href="https://atlas.microsoft.com/sdk/javascript/mapcontrol/3/atlas.min.css" />
    <style>
        html, body { margin: 0; padding: 0; height: 100%; width: 100%; }
        #myMap { width: 100%; height: 100vh; }

        #stopRunBtn  {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 32px;
            background-color: red;
            color: white;
            border: none;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #pauseRunBtn  {
            position: fixed;
            bottom: 20px;
            left: 100px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 32px;
            background-color: orange;
            color: white;
            border: none;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        #confirmLocationBtn {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 28px;
            background-color: #28A745;
            color: white;
            border: none;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #eventMenu {
            position: fixed;
            bottom: 90px;
            left: 20px;
            z-index: 1000;
            display: none;
        }

        #eventCard {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            padding: 15px 20px;
            width: 250px;
            transition: all 0.3s ease;
        }

        #eventCard h3 {
            margin: 0 0 10px;
        }

        #eventCard button {
            margin-right: 10px;
            margin-top: 10px;
            padding: 5px 10px;
            border: none;
            border-radius: 6px;
            background-color: #0078D4;
            color: white;
            cursor: pointer;
        }

        #eventCard button:last-child {
            background-color: #ccc;
            color: black;
        }
        #userBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            background-color: white;
            color: #333;
            border: 1px solid #ccc;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        #userMenu {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1000;
        }

        #userCard {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            padding: 15px 20px;
            width: 250px;
            transition: all 0.3s ease;
        }

        #userCard h3, #userCard h4 {
            margin: 10px 0 5px;
        }

        #userCard ul {
            padding-left: 20px;
            margin: 0;
        }

        #userCard li {
            margin-bottom: 5px;
            font-size: 14px;
        }

        .user-menu {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        .user-menu-button {
            background: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .menu-arrow {
            font-size: 12px;
            color: #666;
        }

        .user-menu-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            margin-top: 5px;
            min-width: 120px;
        }

        .user-menu-dropdown.show {
            display: block;
        }

        .menu-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        .logout-button {
            color: #ff4444;
        }

        .logout-button:hover {
            background: #fff0f0 !important;
        }

        .user-card {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            padding: 10px;
            z-index: 1000;
        }

        .user-menu {
            position: relative;
        }

        .user-menu-button {
            background: none;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
            text-align: left;
        }

        .menu-arrow {
            font-size: 12px;
            color: #666;
        }

        .user-menu-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            margin-top: 5px;
        }

        .user-menu-dropdown.show {
            display: block;
        }

        .menu-item {
            display: block;
            width: 100%;
            padding: 8px 12px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        .logout-button {
            color: #ff4444;
        }

        .logout-button:hover {
            background: #fff0f0 !important;
        }

        #legendOverlay {
             position: fixed;
             top: 20px;
             left: 20px;
             background: rgba(255, 255, 255, 0.95);
             padding: 10px 12px;
             border-radius: 8px;
             box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
             z-index: 1000;
             font-size: 14px;
             line-height: 1.5;
             max-width: 280px;
             color: #333;
         }

        #legendOverlay h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #0078D4;
        }
        #legendOverlay .legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        #legendOverlay .close-btn {
            background: transparent;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
        }

        #legendOverlay p {
            margin-bottom: 3px;
        }

        #legendOverlay .icon-description {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 3px;
        }

        #legendOverlay .icon-description .icon {
            font-size: 20px;
            color: #0078D4;
        }
    </style>

    <script>
        let map;
        let runActive = false;
        let currentUser = null;
        let currentUserId = null; // Add userId for proper filtering
        let currentEventRun = null;
        let eventRunners = new Map(); // Map of userId -> runner data
        let eventRunnerMarkers = new Map(); // Map of userId -> marker
        let eventTrackId = null;
        let eventTrackLayer = null;
        let eventTrackSource = null;

        function getMap() {
            map = new atlas.Map('myMap', {
                center: [34.8, 32.1],
                zoom: 10,
                view: 'Auto',
                authOptions: {
                    authType: 'subscriptionKey',
                    subscriptionKey: 'BSDCG4i6BIsimtM5jNRtCupaIm4boJb8WM92OhKd3jL6x14l3W6mJQQJ99BEACi5YpzPSPD9AAAgAZMP337x',
                }
            });

            map.events.add('ready', function() {

                // Wait a short moment to ensure the camera is settled
                window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'mapReady'}}));
                window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'getEvents'}}));
                const legend = document.getElementById('legendOverlay');
                if (legend) legend.style.display = 'block';
                window.document.addEventListener('message', function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        const type  = data.type || {};
                        if (type === 'eventList') {
                            // Handle event list
                            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'Received event list'}}));
                            const events  = data.events || [];

                            // --- ROBUST MARKER HANDLING ---
                            // 1. Clear all existing event markers from the map and our tracking array
                            if (window.eventMarkers && window.eventMarkers.length > 0) {
                                map.markers.remove(window.eventMarkers);
                            }
                                window.eventMarkers = [];
                            // --- END ROBUST HANDLING ---

                            // Store my events
                            if (!window.myEvents) {
                                window.myEvents = [];
                            }

                            for (let i = 0; i < events.length; i++) {
                                const { latitude, longitude, id, name, host } = events[i];
                                if (isNaN(latitude) || isNaN(longitude)) {
                                    console.warn(`‚ö†Ô∏è Skipping event ${id} due to invalid coordinates`);
                                    continue;
                                }
                                const marker = new atlas.HtmlMarker({
                                    position: [longitude, latitude],
                                    text: 'üìç',
                                    color: '#0078D4'
                                });
                                
                                // Store eventId on the marker object itself
                                marker.eventId = id;

                                map.markers.add(marker);
                                window.eventMarkers.push(marker);

                                map.events.add('click', marker, () => {
                                    window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'openEventDisplay', eventObject: events[i]}}));
                                });

                                if (host === currentUser) {
                                    // Show delete button for events created by current user
                                    // ... rest of the code ...
                                }
                            }

                            // Update the "My Events" list
                            //renderMyEventsList();

                        } else if (type === "usersEvents"){
                            usersEvents = data.events || [];

                            console.log('Received users events:', usersEvents);
                            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'Received users events:' + usersEvents}}));
                            window.myEvents = []; // Reset my events
                            usersEvents.forEach(event => {
                                window.myEvents.push({ id: event.id, name: event.name, latitude: event.latitude, longitude: event.longitude });
                            });
                            renderMyEventsList();
                        }
                        else if (type === 'userLocation') {
                            const { location } = data;
                            
                            if (runActive) {
                                runLoc(location);
                            }

                            if (!window.userMarker) {
                                window.userMarker = new atlas.HtmlMarker({
                                    position: [location.coords.longitude, location.coords.latitude],
                                    text: 'üßç',
                                    color: '#2ecc71'
                                });
                                map.markers.add(window.userMarker);
                            } else {
                                window.userMarker.setOptions({
                                    position: [location.coords.longitude, location.coords.latitude]
                                });
                            }
                        }else if (type === "startSelectingLocation"){
                            // Start location selection
                            startLocationSelection();
                        } else if (type === 'tracks') {
                            console.log('Received track list:', data.data);
                            const tracks  = data.tracks || [];
                            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'Received track list'}}));
                            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: data.tracks}}));
                            window.tracks = tracks; // Add this line
                            for (let i = 0; i < tracks.length; i++) {
                                const { path, id } = tracks[i];
                                if (!path || !Array.isArray(path) || path.length === 0) {
                                    console.warn(`‚ö†Ô∏è Skipping track ${id} due to invalid path`);
                                    continue;
                                }
                                // Draw the path on the map
                                drawPath(tracks[i]);
                            }
                        }else if (type === 'startTrackSelection') {
                            console.log('Starting track selection');
                            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'Starting track selection'}}));
                            enableTrackSelection();

                        }else if (type === 'startFreeRun') {
                            startRun('free', null);
                        }else if (type === 'startEventRun') {
                            startRun('event', data.data);
                        }else if (type === 'updateEventRunners') {
                            updateEventRunners(data.data);
                        }else if (type === 'updateRunnerPosition') {
                            updateRunnerPosition(data.data);
                        }else if (type === 'removeRunner') {
                            removeRunner(data.data.userId);
                        }else if (type === 'log') {
                            console.log('Log from WebView:', data.message);
                        }else if (type === 'eventRunEnded') {
                            clearEventRunState();
                        }else {
                            console.warn('Unknown message type:', type);
                        }
                    } catch (err) {
                        console.error("Failed to parse message:", event.data, "\nError:", err);
                        window.ReactNativeWebView.postMessage(JSON.stringify({
                            data: {
                                action: 'log',
                                message: 'Error parsing message: ' + err.message
                            }
                        }));
                    }
                })
            })
        }
    
    let tempMarker = null;
    let trackingCenter = false;

    function startLocationSelection() {
        // show the confirm button
        document.getElementById('confirmLocationBtn').style.display = 'inline';

        trackingCenter = true;

        // Drop a marker at the current center
        const center = map.getCamera().center;

        if (!tempMarker) {
            tempMarker = new atlas.HtmlMarker({
                position: center,
                draggable: false,
                color: 'DodgerBlue',
                visible: true
            });
            map.markers.add(tempMarker);
        } else {
            tempMarker.setOptions({ position: center, visible: true });
        }

        // Move the marker as the map moves
        console.log("Binding move event...");
        map.events.add('move', updateMarkerPosition);
    }

    function updateMarkerPosition() {
        if (trackingCenter && tempMarker) {
            const center = map.getCamera().center;
            console.log("Map moved. Center is:", center);
            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'Map moved'}}));
            tempMarker.setOptions({ position: center });
        }
    }

    function confirmLocation() {
        trackingCenter = false;
        map.events.remove('move', updateMarkerPosition);

        const pos = tempMarker.getOptions().position;

        tempMarker.setOptions({ visible: false });

        window.ReactNativeWebView.postMessage(JSON.stringify({
            data: {
                action: 'confirmLocation',
                location: {
                    latitude: pos[1],
                    longitude: pos[0]
                }
            }
        }));

        // Hide confirm button
        document.getElementById('confirmLocationBtn').style.display = 'none';
    }
    function closeEventMenu() {
        document.getElementById('eventMenu').style.display = 'none';
    }
    function toggleUserMenu() {
        const menu = document.getElementById('userMenu');
        menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }

    function closeUserMenu() {
        document.getElementById('userMenu').style.display = 'none';
    }
    let trackMarkers = [];
    let trackLineLayers = [];
    let selectedTrackId = null;
    let selectedTrackLon = null;
    let selectedTrackLat = null;

    function enableTrackSelection() {
        showCancelTrackSelectionButton();
        // Assume window.trackMarkers is a list of track marker objects
        trackMarkers.forEach(marker => {

            marker.setOptions({ visible: true }); // Show the marker
        });

        window.eventMarkers.forEach(marker => {
            marker.setOptions({ visible: false }); // Hide event markers
        });
    }

    function showSelectTrackButton() {
        if (!document.getElementById('selectTrackBtn')) {
            const btn = document.createElement('button');
            btn.id = 'selectTrackBtn';
            btn.innerText = '‚úÖ Select This Track';
            btn.style.position = 'fixed';
            btn.style.bottom = '90px';
            btn.style.left = '50%';
            btn.style.transform = 'translateX(-50%)';
            btn.style.zIndex = 1000;
            btn.style.padding = '10px 20px';
            btn.style.backgroundColor = '#0078D4';
            btn.style.color = 'white';
            btn.style.border = 'none';
            btn.style.borderRadius = '8px';
            btn.onclick = confirmSelectedTrack;

            document.body.appendChild(btn);
        }
    }

    function showCancelTrackSelectionButton() {
        if (!document.getElementById('cancelTrackSelectionBtn')) {
            const btn = document.createElement('button');
            btn.id = 'cancelTrackSelectionBtn';
            btn.innerText = 'Cancel';
            btn.style.position = 'fixed';
            btn.style.bottom = '45px';
            btn.style.left = '50%';
            btn.style.transform = 'translateX(-50%)';
            btn.style.zIndex = 1000;
            btn.style.padding = '10px 20px';
            btn.style.backgroundColor = '#0078D4';
            btn.style.color = 'white';
            btn.style.border = 'none';
            btn.style.borderRadius = '8px';
            btn.onclick = cancelTrackSelection;

            document.body.appendChild(btn);
        }
    }

    function confirmSelectedTrack() {
        if (selectedTrackId) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
                data: {
                    action: 'trackSelected',
                    trackId: selectedTrackId,
                    location: {
                        longitude: selectedTrackLon,
                        latitude: selectedTrackLat
                    }
                }
            }));

            // Clean up
            const cancelBtn = document.getElementById('cancelTrackSelectionBtn');
            const selectBtn = document.getElementById('selectTrackBtn');
            if (cancelBtn) cancelBtn.remove();
            if (selectBtn) selectBtn.remove();
            trackMarkers.forEach(marker => {
                marker.setOptions({ visible: false }); // Hide the markers
            });
            trackLineLayers.forEach(layer => {
                layer.setOptions({ visible: false }); // Hide the tracks
            });

            window.eventMarkers.forEach(marker => {
            marker.setOptions({ visible: true }); // Show event markers
            });

        }
    }

    function cancelTrackSelection() {
        window.ReactNativeWebView.postMessage(JSON.stringify({
            data: {
                action: 'cancelTrackSelection'
            }
        }));

        // Clean up
        const cancelBtn = document.getElementById('cancelTrackSelectionBtn');
        const selectBtn = document.getElementById('selectTrackBtn');
        if (cancelBtn) cancelBtn.remove();
        if (selectBtn) selectBtn.remove();
        trackMarkers.forEach(marker => {
            marker.setOptions({ visible: false }); // Hide the markers
        });
        trackLineLayers.forEach(layer => {
            layer.setOptions({ visible: false }); // Hide the tracks
        })
        window.eventMarkers.forEach(marker => {
            marker.setOptions({ visible: true }); // Show event markers
        });
    }

    function drawPath(track) {
        let path = track.path || [];
        try{
            const marker = new atlas.HtmlMarker({
                position: path[0],
                text: 'üèÅ',
                color: '#e67e22',
                visible: false
            });
            marker.trackId = track.trackId; // <-- store the track ID here
            trackMarkers.push(marker);
            
            map.markers.add(marker);
            // Create a LineString geometry
            const line = new atlas.data.LineString(path);
            const feature = new atlas.data.Feature(line);
            
            // Create a DataSource and add the line feature to it
            const dataSource = new atlas.source.DataSource();
            map.sources.add(dataSource);
            dataSource.add(feature);
            
            // Create a line layer and add it to the map
            const lineLayer = new atlas.layer.LineLayer(dataSource, null, {
                strokeColor: 'red',
                strokeWidth: 3,
                visible: false, // Initially hidden
            });
            trackLineLayers.push(lineLayer);
            map.layers.add(lineLayer);
            map.events.add('click', marker, () => {
                // Toggle visibility of the line layer
                const isVisible = lineLayer.getOptions().visible;
                lineLayer.setOptions({ visible: !isVisible });
                selectedTrackId = marker.trackId; // or marker.metadata.id
                selectedTrackLon = marker.getOptions().position[0];
                selectedTrackLat = marker.getOptions().position[1];
                showSelectTrackButton();
            });
        }   catch (err) {
            console.error("Failed to draw path:", err);
            window.ReactNativeWebView.postMessage(JSON.stringify({
                data: {
                    action: 'log',
                    message: 'Error drawing path: ' + err.message
                }
            }));
        }
    }

    function renderMyEventsList() {
        const list = document.getElementById('myEventsList');
        list.innerHTML = ''; // Clear existing list
        window.myEvents.forEach(event => {
            const li = document.createElement('li');
            li.textContent = event.name || 'Untitled Event';
            li.style.cursor = 'pointer';
            li.onclick = () => {
            if (map && event.latitude && event.longitude) {
                map.setCamera({
                center: [event.longitude, event.latitude],
                zoom: 15
                });
            }
            };
            list.appendChild(li);
        });
    }
        // Free Run functionality
        let runType = null;
        let runPaused = false;
        let runPath = [];
        let freeRunWatchId = null;
        let runStartTime = null;
        let runPolylineSource = null;
        let runDataSource = null;
        let runTimerInterval = null;
        let totalPausedTime = 0;
        let pauseStartTime = null;
        let totalRunTime = 0

        function startRun(type, eventData) {
            const overlay = document.getElementById('countdownOverlay');
            const text = document.getElementById('countdownText');
            overlay.style.display = 'flex';
            let count = 3;
            runType = type;

            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: runType === 'free' ? 'enterFreeRunMode' : 'enterEventRunMode'}}))

            text.textContent = count;
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    text.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    overlay.style.display = 'none';

                    // Check if GPS is available before starting run
                    if (!navigator.geolocation) {
                        console.error('Geolocation is not supported by this browser');
                        window.ReactNativeWebView.postMessage(JSON.stringify({
                            data: {
                                action: 'log',
                                message: 'Geolocation is not supported by this browser'
                            }
                        }));
                        return;
                    }

                    runActive = true;
                    runPaused = false;
                    runPath = [];
                    runStartTime = Date.now();
                    totalPausedTime = 0;
                    totalRunTime = 0;
                    if (runType === "event") currentEventRun = eventData;

                    updateRunTimer(); // Immediately update UI
                    runTimerInterval = setInterval(updateRunTimer, 1000);

                    document.getElementById('pauseRunBtn').style.display = 'inline';
                    document.getElementById('stopRunBtn').style.display = 'inline';
                    document.getElementById('runStats').style.display = 'block';
                    const legend = document.getElementById('legendOverlay');
                    if (legend) legend.style.display = 'none';

                    if (!runDataSource) {
                        runDataSource = new atlas.source.DataSource();
                        map.sources.add(runDataSource);
                        map.layers.add(new atlas.layer.LineLayer(runDataSource, null, {
                            strokeColor: 'blue',
                            strokeWidth: 3
                        }));
                    }

                    if (runType === 'event') {
                        if (eventData.trackId) showEventTrack(eventData.trackId);
                    }

                    window.eventMarkers.forEach(marker => {
                        marker.setOptions({ visible: false }); // Hide event markers
                    });
                }
            }, 1000);
        }

        function runLoc(location){
            if (!runActive || runPaused) return;

            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'Run location updated with coords: ' + JSON.stringify(location.coords)}}));
            const { latitude, longitude, speed, heading } = location.coords;
            const point = [longitude, latitude];

            runPath.push(point);
            map.setCamera({ center: point , zoom: 20, bearing: heading ?? 0, pitch: 60 });

            const line = new atlas.data.LineString(runPath);
            runDataSource.setShapes([new atlas.data.Feature(line)]);

            const distance = calculateTotalDistance(runPath);
            const elapsed = (Date.now() - runStartTime) / 1000;
            const pace = distance > 0 ? (elapsed / 60) / (distance / 1000) : 0;
            const cal = estimateCalories(distance);
            const spd = speed ? (speed * 3.6).toFixed(1) : '0';
            
            document.getElementById('runSpeed').textContent = spd;
            document.getElementById('runDistance').textContent = distance.toFixed(1);
            document.getElementById('runPace').textContent = pace.toFixed(2);
            document.getElementById('runCalories').textContent = cal.toFixed(0);

            if (runType === 'event') {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    data: {
                        action: 'updateEventPosition',
                        location: location
                    }
                }));
            }
        }

        function pauseRun() {
            runPaused = !runPaused;
            document.getElementById('pauseRunBtn').textContent = runPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
            if(runPaused){
                pauseStartTime = new Date();

            }else{
                const now = new Date();
                totalPausedTime += now - pauseStartTime;
                pauseStartTime = null;
            }
        }

        function stopRun() {
            runActive = false;

            document.getElementById('pauseRunBtn').style.display = 'none';
            document.getElementById('stopRunBtn').style.display = 'none';
            document.getElementById('runStats').style.display = 'none';
            const legend = document.getElementById('legendOverlay');
            if (legend) legend.style.display = 'block';

            console.log('Run complete. Total path:', runPath);
            if (runTimerInterval) {
                clearInterval(runTimerInterval);
                runTimerInterval = null;
            }

            window.eventMarkers.forEach(marker => {
                marker.setOptions({ visible: true }); // Show event markers
            });
            map.setCamera({ zoom: 15, bearing: 0, pitch: 0 });

            // Remove the free run line from the map
            if (runDataSource) {
                runDataSource.setShapes([]);
            }

            const totalDistance = calculateTotalDistance(runPath);
            // Display summary
            // document.getElementById('runStats').style.display = 'none';
            // document.getElementById('runSummary').style.display = 'block';
            // window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'showing run summary menu'}}));

            // Set stats
            // document.getElementById('summaryTime').textContent = document.getElementById('runTime').textContent;
            // document.getElementById('summaryDistance').textContent = totalDistance.toFixed(1);
            // document.getElementById('summaryCalories').textContent = estimateCalories(totalDistance, freeRunStartTime);

            // const pace = totalDistance > 0 ? (totalRunTime / 60) / (totalDistance / 1000) : 0;
            // document.getElementById('summaryPace').textContent = pace.toFixed(2);

            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'leaveRunMode'}}));
            // drawSummaryRoute();

            // Calculate stats
            const duration = totalRunTime; // in seconds
            const averageSpeed = totalDistance > 0 ? (totalDistance / duration) * 3.6 : 0; // km/h
            const averagePace = totalDistance > 0 ? (duration / 60) / (totalDistance / 1000) : 0; // min/km
            const calories = estimateCalories(totalDistance);

            // Build activity object
            var activity = {
                userId: currentUser, // or get from storage/context
                timestamp: new Date().toISOString(),
                distance: totalDistance,
                duration: duration,
                averageSpeed: averageSpeed,
                averagePace: averagePace,
                calories: calories,
                start_time: new Date(runStartTime).toISOString(),
                stop_time: new Date().toISOString(),
                type: (runType === 'free') ? 'Free Run' : 'Event Run', // or other type
                path: runPath // if you want to store the path
            };

            if (runType === 'event') {
                activity.eventId = currentEventRun.eventId;
                if (currentEventRun.trackId) activity.trackId = currentEventRun.trackId;
            }

            // Validate that we have a valid path before creating activity
            if (runPath && runPath.length >= 2) {
                // Check if the run has meaningful distance (at least 10 meters)
                if (totalDistance >= 10) {
                    createActivity(activity, runPath);
                    // Show success message
                    showRunStatusMessage('Run saved successfully!', 'success');
                } else {
                    console.warn('Cannot create activity: Run distance too short (less than 10 meters)');
                    showRunStatusMessage('Run too short to save (minimum 10 meters)', 'warning');
                    window.ReactNativeWebView.postMessage(JSON.stringify({
                        data: {
                            action: 'log',
                            message: 'Cannot create activity: Run distance too short (less than 10 meters)'
                        }
                    }));
                }
            } else {
                console.warn('Cannot create activity: Empty or invalid run path');
                showRunStatusMessage('No GPS data recorded - run not saved', 'error');
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    data: {
                        action: 'log',
                        message: 'Cannot create activity: Empty or invalid run path'
                    }
                }));
            }

            if (runType === 'event') {
                window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'endEventRun'}}));
                clearEventRunState();
            }
        }

        function clearEventRunState() {
            // Clear event run state
            currentEventRun = null;
            eventRunners.clear();
            eventRunnerMarkers.forEach(marker => {
                map.markers.remove(marker);
            });
            eventRunnerMarkers.clear();

            // Remove event track from map
            if (eventTrackLayer) {
                map.layers.remove(eventTrackLayer);
                eventTrackLayer = null;
            }
            if (eventTrackSource) {
                map.sources.remove(eventTrackSource);
                eventTrackSource = null;
            }
            runType = null;
        }

        function closeRunSummary() {
            document.getElementById('runSummary').style.display = 'none';
        }

        function calculateTotalDistance(coords) {
            if (coords.length < 2) return 0;
            let d = 0;
            for (let i = 1; i < coords.length; i++) {
                d += atlas.math.getDistanceTo(coords[i - 1], coords[i], 'meters');
            }
            return d;
        }

        function estimateCalories(distanceMeters) {
            const distanceKm = distanceMeters / 1000;
            const MET = 9.8;
            const weightKg = 70;
            const hours = (Date.now() - runStartTime) / (1000 * 60 * 60);
            return MET * weightKg * hours;
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('pauseRunBtn').onclick = pauseRun;
            document.getElementById('stopRunBtn').onclick = stopRun;
        });

        function updateRunTimer() {
            if (!runStartTime || runPaused) return;
                const now = new Date();
                const elapsed = Math.floor((now - runStartTime - totalPausedTime) / 1000); // in seconds

                totalRunTime = elapsed; // Update total run time


                const hours = String(Math.floor(elapsed / 3600)).padStart(2, '0');
                const minutes = String(Math.floor((elapsed % 3600) / 60)).padStart(2, '0');
                const seconds = String(elapsed % 60).padStart(2, '0');

                document.getElementById('runTime').textContent = `${hours}:${minutes}:${seconds}`;
        }

        // free run ends here
        
        function showEventTrack(trackId) {
            if (!window.tracks) {
                console.warn('No tracks loaded');
                window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'No tracks loaded'}}));
                return;
            }
            const track = window.tracks.find(t => t.trackId === trackId || t.id === trackId);
            if (!track) {
                console.warn('Track not found for id:', trackId);
                window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'Track not found for id: ' + trackId}}));
                return;
            }
            if (window.tracks && track) {
                window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'log', message: 'Track found for id: ' + trackId}}));
            }

            // Draw the new event track
            let path = track.path || [];
            eventTrackSource = new atlas.source.DataSource();
            map.sources.add(eventTrackSource);

            const line = new atlas.data.LineString(path);
            const feature = new atlas.data.Feature(line);
            eventTrackSource.add(feature);

            eventTrackLayer = new atlas.layer.LineLayer(eventTrackSource, null, {
                strokeColor: 'red',
                strokeWidth: 10,
                strokeOpacity: 0.6,
                visible: true,
            });
            map.layers.add(eventTrackLayer);
        }

        function updateEventRunners(runners) {
            // Clear existing runners
            eventRunnerMarkers.forEach(marker => {
                map.markers.remove(marker);
            });
            eventRunnerMarkers.clear();

            // Add new runners
            runners.forEach(runner => {
                if (runner.userId !== currentUserId) { // Use userId for filtering
                    const marker = new atlas.HtmlMarker({
                        position: [runner.longitude, runner.latitude],
                        text: 'üèÉ',
                        color: '#e74c3c'
                    });
                    eventRunnerMarkers.set(runner.userId, marker);
                    map.markers.add(marker);
                }
            });
        }

        function updateRunnerPosition(positionData) {
            if (positionData.userId === currentUserId) return; // Use userId for filtering

            let marker = eventRunnerMarkers.get(positionData.userId);
            if (!marker) {
                // Create new marker for this runner
                marker = new atlas.HtmlMarker({
                    position: [positionData.longitude, positionData.latitude],
                    text: 'üèÉ',
                    color: '#e74c3c'
                });
                eventRunnerMarkers.set(positionData.userId, marker);
                map.markers.add(marker);
            } else {
                // Update existing marker
                marker.setOptions({
                    position: [positionData.longitude, positionData.latitude]
                });
            }
        }

        function removeRunner(userId) {
            console.log('Removing runner:', userId);
            const marker = eventRunnerMarkers.get(userId);
            if (marker) {
                map.markers.remove(marker);
                eventRunnerMarkers.delete(userId);
            }
        }

        // Event run ends here

        // Add a function to receive the username from React Native
        window.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'userIdentity') {
                    currentUser = data.username;
                    currentUserId = data.userId; // Store userId for filtering
                    // Update username display
                    const userElements = document.getElementsByClassName('current-user');
                    for (let element of userElements) {
                        element.textContent = currentUser;
                    }
                }
            } catch (error) {
                console.error('Error processing message:', error);
            }
        });

        // Add logout function
        function handleLogout() {
            window.ReactNativeWebView.postMessage(JSON.stringify({data: {action: 'logout'}}));
        }

        document.addEventListener('DOMContentLoaded', function() {
            const menuButton = document.getElementById('userMenuButton');
            const dropdown = document.getElementById('userMenuDropdown');

            menuButton.addEventListener('click', function(e) {
                e.stopPropagation();
                dropdown.classList.toggle('show');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!menuButton.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.classList.remove('show');
                }
            });
        });

        function navigateToProfile() {
            window.ReactNativeWebView.postMessage(JSON.stringify({
                data: {
                    action: 'navigateToProfile'
                }
            }));
        }

        function createActivity(activity, path) {
            window.ReactNativeWebView.postMessage(JSON.stringify({
                data:{ action: 'logRun', activity: activity, track: {path: path}}
            }));
        }

        function showRunStatusMessage(message, type) {
            // Remove existing message if any
            const existingMessage = document.getElementById('runStatusMessage');
            if (existingMessage) {
                existingMessage.remove();
            }

            // Create message element
            const messageDiv = document.createElement('div');
            messageDiv.id = 'runStatusMessage';
            messageDiv.textContent = message;
            messageDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: ${type === 'success' ? '#28a745' : type === 'warning' ? '#ffc107' : '#dc3545'};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                font-size: 16px;
                font-weight: bold;
                z-index: 3000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                text-align: center;
                max-width: 300px;
            `;

            document.body.appendChild(messageDiv);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 3000);
        }
    </script>
</head>
<body onload="getMap()">
    <div id="myMap"></div>

    <button id="confirmLocationBtn"
        onclick="confirmLocation()"
        style="display:none;">
        ‚úÖ
    </button>

<button id="userBtn" onclick="navigateToProfile()">üë§</button>

<div id="runControls" style="position: absolute; top: 10px; left: 10px; z-index: 1000;">
  <button id="pauseRunBtn" style="display:none;">‚è∏Ô∏è</button>
  <button id="stopRunBtn" style="display:none;">‚èπ</button>
</div>

<div id="runStats" style="display: none; position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 8px; border-radius: 8px; z-index: 1000;">
  <p>Time: <span id="runTime">00:00:00</span></p>
  <p>Speed: <span id="runSpeed">0</span> km/h</p>
  <p>Distance: <span id="runDistance">0</span> m</p>
  <p>Pace: <span id="runPace">0</span> min/km</p>
  <p>Calories: <span id="runCalories">0</span></p>
</div>

<div id="runSummary" style="display: none; position: absolute; top: 10%; left: 5%; right: 5%; background: white; padding: 20px; border-radius: 15px; box-shadow: 0 0 10px rgba(0,0,0,0.3); z-index: 1000;">
  <h2>Run Summary</h2>
  <p><strong>Time:</strong> <span id="summaryTime">--</span></p>
  <p><strong>Distance:</strong> <span id="summaryDistance">--</span> m</p>
  <p><strong>Avg Pace:</strong> <span id="summaryPace">--</span> min/km</p>
  <p><strong>Calories:</strong> <span id="summaryCalories">--</span></p>
  <div id="summaryMap" style="height: 200px; margin-top: 15px;"></div>
  <button onclick="closeRunSummary()">Close</button>
</div>

<div id="countdownOverlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); color: white; font-size: 64px; font-weight: bold; align-items: center; justify-content: center; z-index: 2000;">
  <div id="countdownText">3</div>
</div>

<div id="legendOverlay" style="display: none; position: fixed; top: 70px; left: 20px; background: rgba(255, 255, 255, 0.95); padding: 10px 12px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); z-index: 1000; font-size: 14px; line-height: 1.5; max-width: 280px; color: #333;">
    <div class="legend-header"><h4 style="margin:0;">Map Legend</h4><button class="close-btn" onclick="(function(){document.getElementById('legendOverlay').style.display='none';})()">‚úï</button></div>
    <p><span class="icon-description"><span class="icon">üìç</span>Event Location</span></p>
    <p><span class="icon-description"><span class="icon">üßç</span>Your Location</span></p>
    <p><span class="icon-description"><span class="icon">üèÉ</span>Runner</span></p>
    <p><span class="icon-description"><span class="icon">üèÅ</span>Track Start/Finish</span></p>
    <p><span class="icon-description"><span class="icon">üîó</span>Track Path</span></p>
  </div>

</body>
</html>